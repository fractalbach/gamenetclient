<!DOCTYPE html>
<html lang="en">
  <head>
    <title>ðŸ’¥ [Offline Bomba] ðŸ’£ </title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script type="text/javascript">
"use strict";        

// TODO:
// 
//    - Fix bug with the (x-1) and (y-1) thing.
//    - Add hidden <button> to do tab switching.  Focus automatically to first elem.
//    - 
//
// __________________________________________________________________________
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//                             Global Variables
// __________________________________________________________________________
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


//                        ~ The Holy Page Divider ~ 
//                 ~ Only to be used in times of Emergency ~

// 
//                                 ~ | ~
//    |------------------------------+------------------------------| 
//                                 ~ | ~

// Colors of the Various Types of Squares
var PLAYER_1 = "#0B0";
var PLAYER_2 = "#44F";
var SQUARE_3 = "#B00";
var SQUARE_4 = "#C22";
var SQUARE_5 = "#D44";
var SQUARE_6 = "#E66";
var SQUARE_7 = "#F88";
var EMPTY_SQUARE = "#AAA";
var UNKNOWN_SQUARE = "#A55";


// Dimensions of the Map and the Canvas Grid
var MAP_WIDTH = 24; 
var MAP_HEIGHT = 24;
//var canvasSize = {x: 1248, y: 1248};
// var canvasSize = {x: 624, y: 624};
var canvasSize = {x: 960, y: 960};
var grid = {size: {x: MAP_WIDTH, y: MAP_HEIGHT}};
var gridBox = {
  x: canvasSize.x / MAP_WIDTH, 
  y: canvasSize.y / MAP_HEIGHT
};


// Creating the Cellular Automata
var myLife = new Life(MAP_WIDTH, MAP_HEIGHT);


// About the Game Timer 
// Search for GameUpdate() to see the function that triggers.
//
var GameTickRate = 500; // in milliseconds
var TickCount = 0;


// The Generation Number # when the player input stops, and the game ends.
var GAME_ENDS_GEN = 50;
var Round = 0;
var gameHasEnded = false;


function Game()
{
  this.MapWidth;
  this.MapHeight;
  this.Life;
}



// __________________________________________________________________________
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//                          Cellular Automata
// __________________________________________________________________________
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


// Life is the object that holds EVERYTHING about the current state 
// of the Cellular Automata.  This includes both its state, and the 
// functions that define its rules. 
//
// Try changing the "this.GetNextCellValue()" Function to mess around
// with the automata rules!  Or define a new type of "Neighborhood"!
// 


function Life(w, h)
{
  this.w = w;
  this.h = h;
  this.generation = 0;
  this.current = MakeRandomMatrix(w, h, 0, 1);
  this.future = MakeNewMatrix(w, h);
  this.numDisputed = 0;
  this.numGreens = 0;
  this.numBlues = 0;
  this.neighbors = [
    Loc(-1, -1),
    Loc(-1,  0),
    Loc(-1,  1),
    Loc( 0, -1),
    Loc( 0,  1),
    Loc( 1, -1),
    Loc( 1,  0),
    Loc( 1,  1),
  ];


  //  ______________________________________________________________________
  // +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
  //                       Change Stuff Here!                        
  // +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
  //  GetNextCellValue is where the fun all happens!  
  //  Input: the x,y coordinates of the cell you are investigating
  //  Output: the Cell Type that it will become in the next generation!
  // 
  //  Try changing around the rules of this function to get interesting
  //  results! 
  //

  this.GetNextCellValue = function(a, b) {

    var me = this.WhatIs(a, b); // The cell we are looking at.
    var n = this.CountNeighbors(a, b);

    var S = this.WhatIs(a, b + 1); // South
    var N = this.WhatIs(a, (b - 1)); // North
    var W = this.WhatIs((a - 1), b); // West
    var E = this.WhatIs(a + 1, b); // East
    var NE = this.WhatIs(a+1, b-1);
    var NW = this.WhatIs(a-1, b-1);
    var SE = this.WhatIs(a+1, b+1);
    var SW = this.WhatIs(a-1, b+1);
    
    if (me == undefined) {return 0;}
    if (me >= 7) {return 0;}
    if (me >= 3) {return (me+1);}
        
    switch(me)
    {           
      case 0: //---------------------

        var p1 = 0;
        var p2 = 0;

        if (N === 2) {p2++;} // Blue blocks drift Downward
        if (NW === 2) {p2++;}
        if (NE === 2) {p2++;}

        if (S === 1) {p1++;} // Green blocks drift Upward
        if (SW === 1) {p1++;}
        if (SE === 1) {p1++;}

        switch(W)
        {
          case 1: p1++;
          case 2: p2++;
        }
        switch(E)
        {
          case 1: p1++;
          case 2: p2++;
        }

        if (p1 == p2) {return 7;}
        if (p1 > p2) {return 1;}
        if (p1 < p2) {return 2;}

        // if (E === 2) {return 2;} // Blue blocks drift to the Left
        // if (W === 1) {return 1;} // Green Blocks drift Right
        break; 

      case 1: //---------------------
        if (n[2] >= 4) {return 2;}
        break; 

      case 2: //---------------------


        if (n[1] >= 4) {return 1;}
        break;
    }
    return me;
  };

  //  ______________________________________________________________________
  // \~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/




  // ChangeValue is a helper function for directly changing a value 
  // on the grid.  Should probably use this if you are clicking stuff.
  //
  this.ChangeValue = function(x, y, newval) 
  {
    if ((x >= this.w) || (y >= this.h) || (x < 0) || (y < 0)) {
      return;
    }
    this.current[x][y] = newval;
    return;
  };

  // ChangeFuture is a setter function that can be passed invalid locations.
  // The function will simply do nothing if the location is out of bounds. 
  this.ChangeFuture = function(x, y, newval) 
  {
    if ((x >= this.w) || (y >= this.h) || (x < 0) || (y < 0)) {
      return;
    }
    this.future[x][y] = newval;
    return;
  };

  // WhatIs is a getter function that returns the value at the given location.
  // Returns 0 if passed an invalid function.
  // Instead 
  this.WhatIs = function(xin, yin) {  
    if ((xin >= this.w) || (yin >= this.h) ||  (xin < 0) || (yin < 0)) {
      return 0;
    }
    return this.current[xin][yin];
  };

  // CountNeighbors returns the counts of cell types that are located 
  // near the given cell at the given coordinates x, y.
  // 
  // "Near" is defined as the 8 cells located around a cell on a 
  // 2-dimensional grid of boxes.  It is also known as the "Moore Area"
  // in Cellular Automata.
  //
  this.CountNeighbors = function(A, B)
  {
      var map = NewNeighborhood(3);
      this.neighbors.forEach( function (box) 
      {
          var value = this.WhatIs(A + box.x, B + box.x);
          map[value]++;
      }, this);
      return map;
  };
  
  // NextGeneration advances the entire Life to the next generation.
  // Using the current grid, it calculates a new state and saves it 
  // into the future grid.  At the end of the calculation, the future 
  // grid replaces the current, and the generation number increases by 1.  
  //
  this.NextGeneration = function() 
  {
    this.future = MakeNewMatrix(this.w, this.h);
    this.ResetColorCount();
    var maxI = this.w;
    var maxJ = this.h;
    for (var i = 0; i < maxI; i++) {
      for (var j = 0; j < maxJ; j++) {
        var newval = this.GetNextCellValue(i, j);
        this.ChangeFuture(i, j, newval);
        this.AddColorCount(newval);
      }
    }
    this.current = this.future;
    this.generation++;
    return this.generation;
  };


  // DropLaBomba will immediately alter a bunch of squares.
  // BOOOOOM!
  this.DropLaBomba = function(x, y)
  {
    for (var i = -2; i <= 2; i++) {
      for (var j = -2; j <= 2; j++) {
        if ((Math.abs(i) === 2) && (Math.abs(j) === 2)) {
          continue;
        }
        this.ChangeValue(x+i, y+j, 3);
      }
    }
  };


  this.AddColorCount = function(val)
  {
    switch(val)
    {
      case 1: this.numGreens++; break;
      case 2: this.numBlues++; break;
      default: this.numDisputed++; break;
    }
  };

  this.ResetColorCount = function()
  {
    this.numBlues = 0;
    this.numGreens = 0;
    this.numDisputed = 0;
  };

  this.ResetLife = function()
  {
    this.generation = 0;
    this.current = MakeRandomMatrix(w, h, 0, 1);
    this.future = MakeNewMatrix(w, h);
    this.numDisputed = 0;
    this.numGreens = 0;
    this.numBlues = 0;
  };

}; // End of Definition of Life Object.

// __________________________________________________________________________
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//                            Helpful Functions 
// __________________________________________________________________________
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


/*
var Vec = function (A,B) {
  this.x = parseInt(A);
  this.y = parseInt(B);
};
*/

function Loc(A,B)
{
  return {
    x: A,
    y: B,
  }
};


// MakeNewMatrix initializes a matrix of zeros. Size = (w * h).
function MakeNewMatrix(w, h) 
{
    var matrix = [];
    for (var i = 0; i < w; i++) {
        var col = [];
        for (var j = 0; j < h; j++) {
            col.push(0);
        }
        matrix.push(col);
    } 
    return matrix;
}

// RandomizeMatrix returns a matrix of integers between lowval and highval. 
function MakeRandomMatrix(w, h, lowval, highval)
{
  var matrix = [];
  for (var i = 0; i < w; i++) {
    var col = [];
    for (var j = 0; j < h; j++) {
      col.push(Math.floor(100 * Math.random()) % 3);
    }
    matrix.push(col);
  }
  return matrix;
}

// Neighborhood returns a Map of Square Types -> how many there are.
// So if n = Neighborhood(), then n[1] = number of #1 type squares.
function NewNeighborhood(numberOfTypes)
{
    var mapz = {};
    for (var iter = numberOfTypes-1; iter >= 0; iter--) {
        mapz[iter] = 0;
    }
    return mapz;
}

// gridHash converts a coordinate pair (x,y) into a single value, while
// still representing the same spot on the grid.  Useful when adding
// unique elements to Sets. 
//
function gridHash(x,y) 
{
    return (x + (y*MAP_WIDTH));
}

// gridUnHash simply reverses the process of gridhash.  Converting a 
// single values back into an (x,y) pair.
function gridUnHash(hash) 
{
    return {
        x: hash % MAP_WIDTH,
        y: Math.floor(hash / MAP_WIDTH)
    };
}



// __________________________________________________________________________
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//         After the Page Loads       +       Main Sequence of Events
// __________________________________________________________________________
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


window.onload = function () {
// asdf
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //                           Start Canvas  
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  // 
  // There are way to many variables here.  My editor has a bright blue
  // color for these variables.  It is burning holes into my eyes just
  // looking at this page.  It also burns a hole into my soul.
  //
  // This has GOT to be terrible practice.
  // 

  var canvas = document.getElementById('MainCanvas');
  var ctx = canvas.getContext('2d');
  canvas.width = canvasSize.x;
  canvas.height = canvasSize.y;

  var w = new World(ctx);
  //w.drawGridLines();
  //w.c.save();

  var ToggleButton = document.getElementById("ButtonToggleCLI");

  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //                      Game Update - Next Gen 
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    

    function UserDoesGameUpdate()
    {
      if (gameHasEnded == true) {
        return;
      }
      if (myLife.generation >= GAME_ENDS_GEN) {
        gameHasEnded = true;
        GameEnd();
        return;
      }
      GameUpdate();
      TurnTracker.ChangeTurns();
      var RoundsLeft = Math.floor((GAME_ENDS_GEN - myLife.generation) / numberOfPlayers);
      document.getElementById('DisplayRoundsLeft').innerHTML = RoundsLeft; 
      return;
    }

  function GameUpdate() 
  {
      myLife.NextGeneration();
      DrawColorsFromByteMatrix(w, myLife.current, MAP_WIDTH, MAP_HEIGHT);
      document.getElementById("InfoBar_Generation").innerHTML = myLife.generation;
      document.getElementById("InfoCountBlues").innerHTML = myLife.numBlues;
      document.getElementById("InfoCountGreens").innerHTML = myLife.numGreens;
      document.getElementById("InfoCountDisputes").innerHTML = myLife.numDisputed;
  }

  function MultipleGameUpdates(numberOfUpdates)
  {
    for (var i=0; i<numberOfUpdates; i++) 
    {
      GameUpdate();
    }
  }


  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //                   Start, End, and Restart the Game 
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  

  function RestartGame()
  {
    myLife.ResetLife();
    gameHasEnded = false;
    document.getElementById("DisplayEndGame").className = "invisible";
    document.getElementById("DisplayTurn").className = "visible";
    GameStartUp();
  }

  // Run A few Primary GameUpdates to get things started.
  function GameStartUp()
  {
    MultipleGameUpdates(5);
    myLife.generation = 1;
    document.getElementById("InfoBar_Generation").innerHTML = myLife.generation;
  }

  GameStartUp();

  // Sequence of events that happen when the game ends.
  // This should be triggered once the Generation Update reaches a certain
  // number. 
  function GameEnd()
  {
    document.getElementById("DisplayTurn").className = "invisible";
    document.getElementById("DisplayEndGame").className = "visible";
    GamesOverClearSmoke().then(function()
    {
      var winner;
      var color;
      if (myLife.numBlues === myLife.numGreens) {
        winner = "Tie!";
        color = "grayText";
      }
      if (myLife.numBlues < myLife.numGreens) {
        winner = "Player 1 has won!";
        color = "greenText";
      }
      if (myLife.numBlues > myLife.numGreens) {
        winner = "Player 2 has won!";
        color = "blueText";
      }
      document.getElementById("DisplayEndGameWinner").innerHTML = winner;
      if (color != false) {
        document.getElementById("DisplayEndGameWinner").className = color;  
      }
    });
  }


  async function GamesOverClearSmoke()
  {
    for (var i=1; i<=10; i++) {
      GameUpdate()
      document.getElementById("DisplayEndGameWinner").innerHTML = "Smoke Clearing... " + i + " generations later...";
      await sleep(500);
    }
    return true;
  }

  

  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //                           Game Timer 
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  // This Would start the Game Ticker, which continuously updates the 
  // game.  But if we want a turn-based game, then we disable it.
  //
  // RunGameTicker();
  //


  function sleep(ms) 
  {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async function RunGameTicker() 
  {
    while (true) 
    {
      GameUpdate();
      await sleep(GameTickRate);
    }
  }

  //window.setTimeout(function() {GameUpdate()}, GameTickRate);

  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //                         Player's Turns
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  // Start up the Turn Tracker, which will keep track of whose turn it 
  // is during the game.
  //
  var TurnTracker = new PlayerTurnObject();

  // PlayerTurnObject holds the current turn by player number,
  // and has a function that will change turns back and forth between
  // 2 players when ChangeTurns() is called.
  //
  function PlayerTurnObject()
  {
    this.player = 1;
    this.ChangeTurns = function()
    {
      if (this.player === 1) {
        this.player = 2;
        ChangeTurnsDisplay(2);
      } else {
        this.player = 1;
        ChangeTurnsDisplay(1);
      }      
    }
  }

  // ChangeTurnsDisplay accepts 1 or 2, and will change the element
  // within the HTML document to a certain color and number to reflect
  // the current player's turn.
  // 
  var numberOfPlayers = 2

  function ChangeTurnsDisplay(playerNum)
  {
    switch (playerNum)
    {
      case 1:
        document.getElementById('DisplayTurnPlayerColor').className = "greenText";
        document.getElementById('DisplayTurnPlayerNumber').innerHTML = playerNum;
        break;
      case 2:
        document.getElementById('DisplayTurnPlayerColor').className = "purpleText";
        document.getElementById('DisplayTurnPlayerNumber').innerHTML = playerNum;
        break;
    }
  }


    


  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //                        Utility Functions
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  // getMousePos figures out where your mouse is relative to the canvas.
  // The values (event.clientX) and (event.clientY) will give you the 
  // mouse position relative to the top left corner of the screen;
  // and will return a value that you probably weren't expecting.
  // 
  // This happens especially when you have scrolled away from the browser's
  // initial position.  So, this handy function will take of that:
  // 
  function getMousePos(canvas, evt) 
  {
      var rect = canvas.getBoundingClientRect();
      return {
          x: evt.clientX - rect.left,
          y: evt.clientY - rect.top,
      };
  }
  
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //                      Canvas Event Listeners 
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //                      Dragging the Mouse 
  //                  (Disabled in Game of War)
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  // Create an array to store the mouse locations the mouse is dragged 
  // across the screen.
  /*
  var userMousePathSet = new Set();
  var lastX;
  var lastY;

  // HandleMouseMove is the function that fires every time the mouse is 
  // dragged across the screen.  It SHOULD happen only when the mouse
  // is pressed down.  It SHOULD also happen on mobiles, when somebody
  // is pressing down and swiping across the surface of the device.
  function HandleMouseMove(event) 
  {
      // Calculate the box that the mouse is currently hovering over.
      var rect = canvas.getBoundingClientRect();
      var x = Math.floor((event.clientX - rect.left)  / gridBox.x);
      var y = Math.floor((event.clientY - rect.top) / gridBox.y);

      // If the mouse is over a new box, we want to remember it.
      // Hash up the (x,y)! Now, a single value can be added to a Set.
      // Remember this box position for the next iteration.
      if ( (x != lastX) || (y != lastY) ) 
      {
          userMousePathSet.add(gridHash(x, y));
          w.drawCharacterBox(x,y , 'gray');
          lastX = x;
          lastY = y;
      }
  }


  // When the mouse is pressed down, track the movements.
  canvas.addEventListener('mousedown', function(event)
  {
    // Quick check to make sure you are on Player1 or Player 2.
    switch (document.getElementById("ColorSelect").value) {
        case '1': case '2': break;
        default: return;
    }
    if (event == null) {
        return;
    }

    // Initialize variables for tracking boxes that mouse passes through.
    lastX = -1;
    lastY = -1;
    userMousePathSet = new Set();

    // Add the MouseMove event listener, which runs this function
    // very frequently while the mouse moves across the canvas.
    canvas.addEventListener('mousemove', HandleMouseMove, true);   
  });

  
  //                                 ~ | ~
  //    |------------------------------+------------------------------| 
  //                                 ~ | ~

  // When the mouse is lifted up, remove the mouseMove listener,
  // and send a message to apply those squares to the grid.
  canvas.addEventListener('mouseup', function(event) 
  {
      // Remove the listener.  Helps prevent pointless events from firing.
      canvas.removeEventListener("mousemove", HandleMouseMove, true);

      var changes = [];

      // UnHash the values from the set into (x,y) coordinates.
      // Then, draw boxes on those squares so that it will look neat.
      userMousePathSet.forEach(function(val) 
      {
          var box = gridUnHash(val);
          //changes.push( getNextLifeChange(box.x, box.y) );
          myLife.ChangeValue(box.x, box.y, UserScribblesAt(box.x, box.y));
          w.drawCharacterBox(box.x, box.y, 'white');
      });
      
      
          // __________________________
          // Cool Accidental Thing: 
          // This will change the highlighted spots into the next gen.
          // var newVal = myLife.GetNextCellValue(box.x, box.y);
          // __________________________


      // Assume that if is only 1 box selected, it was just a regular click.
      // If there are multiple: then it is a bulk message.
      // Format the message, and send it across the websocket connection.
      //if (changes.length >= 2) {
          // var message = {EventType: "ChangeMany", Changes: changes};
          // conn.send(JSON.stringify(message));
      //}

      // Just in case; reinitialize the Set variable.
      userMousePathSet = new Set();
  });

*/

  //                                 ~ | ~
  //    |------------------------------+------------------------------| 
  //                                 ~ | ~
/*
  function getNextLifeChange(x,y) 
  {
    var newval;
    switch (document.getElementById("ColorSelect").value) 
    {
      case '1': 
          newval = 1;
          color = PLAYER_1;
          break;

      case '2': 
          newval = 2; 
          color = PLAYER_2;
          break;

      default:
          return;
    }
    return { Value: newval, Location: {X: x, Y: y,} };
  }
*/

  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //                      Canvas Mouse Click 
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  // Whenever the Canvas is clicked, boxes will be changed!
  // TODO: Only send a message to the server if websocket connection = true
  canvas.addEventListener('click', function(event) 
  {
      if (gameHasEnded == true)
      {
        return;
      }
      // Calculate the Box that the mouse has clicked on.
      var pos = getMousePos(canvas, event);
      var x = Math.floor(pos.x / gridBox.x);
      var y = Math.floor(pos.y / gridBox.y);


      myLife.DropLaBomba(x, y);
      w.drawCharacterBox(x, y, 'white');
      myLife.ChangeValue(x, y, 4);

      UserDoesGameUpdate();

      //var newval;
      // myLife.ChangeValue(x, y, UserScribblesAt(x,y));
      // if (ToggleButton.tabIndex == 1) {ToggleButton.tabIndex = 0;}
  });

  // Stuff that happens when the user "clicks" a square.

  var UserScribblesAt = function(x, y) 
  {
    var oldval = document.getElementById("ColorSelect").value;
    var newval;
    var color;
    switch (oldval) 
    {
        case '1': 
            //LifeChange(x, y, 1);
            newval = 1;
            color = PLAYER_1;
            break;

        case '2': 
            //LifeChange(x, y, 2);
            newval = 2; 
            color = PLAYER_2;
            break;

        case 'bomba1':
        case 'bomba2': 
            newval = 4;
            myLife.DropLaBomba(x, y);
            color = "#FFF";
            break;

        default: return;
    }
    w.drawCharacterBox(x, y, color);
    return newval;
  };

  document.getElementById("ButtonStartGame").addEventListener("click", function(event) 
  {
    document.getElementById("Instructions").className = "invisible";
    document.getElementById("DisplayTurn").className = "visible";
  });

  document.getElementById('ButtonPlayAgain').addEventListener("click", RestartGame, true);

}



    

// __________________________________________________________________________
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//                             Canvas World
// __________________________________________________________________________
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/*
function draw() {
    var canvas = document.getElementById('MainCanvas');
    if (canvas.getContext) {
        var ctx = canvas.getContext('2d');
    } else {
        console.log("Cannot get Context on the Canvas! Exiting Draw Function.")
        return;
    }
    var w = new World(ctx);
    w.drawGridLines();
    w.c.save();
    w.drawCharacterBox(1,1);
    w.drawCharacterBox(3,9);
    w.drawCharacterBox(10,13);
}
*/



function World(context) 
{
    this.c = context;

    this.reDraw = function() {
        var canvas = document.getElementById('MainCanvas');
        //this.c.clearRect(0, 0, canvas.width, canvas.height);
        this.c.fillStyle = 'rgb(0, 0, 0)';
        this.c.fillRect(0, 0, canvas.width, canvas.height);
        //this.drawGridLines();
    };

    this.drawLine = function (x0, y0, xf, yf) {
        this.c.beginPath();
        this.c.moveTo(x0,y0);
        this.c.lineTo(xf,yf);
        this.c.stroke();
    };

    this.drawGridLines = function() {
        this.c.strokeStyle = 'rgb(200, 200, 200)';
        for (var i = grid.size.x - 1; i >= 0; i--) {
            var x0 = i*gridBox.x;
            var xf = x0;
            var y0 = 0;
            var yf = canvasSize.y;
            this.drawLine(x0, y0, xf, yf);
        }
        for (var j = grid.size.x - 1; j >= 0; j--) {
            var x0 = 0;
            var xf = canvasSize.x;
            var y0 = j*gridBox.y;
            var yf = y0;
            this.drawLine(x0, y0, xf, yf);
        }
    };

    this.drawCharacterBox = function(A, B, mycolor) {
        var x = A * gridBox.x + 1;
        var y = B * gridBox.y + 1;
        var width = gridBox.x - 2;
        var height = gridBox.y - 2;
        if (!mycolor) {
            this.c.fillStyle = 'rgb(300, 12, 112)';
        } else {
            this.c.fillStyle = mycolor;
        }
        this.c.fillRect(x, y, width, height);
    };


    this.drawCircle = function(A, B, color) {
        this.c.beginPath();
        if (!mycolor) {
            this.c.fillStyle = 'rgb(0, 200, 200)';
        } else {
            this.c.fillStyle = mycolor;
        }
        this.c.arc(100,75,50,0,2*Math.PI);
        this.c.stroke();
    };
};

function DrawColorsFromByteMatrix(world, matrix, w, h)
{
  var x;
  for (var i = 0; i < w; i++) {
    for (var j = 0; j < h; j++) {
      switch (matrix[i][j]) {
      case 0: x = EMPTY_SQUARE; break;
      case 1: x = PLAYER_1; break;
      case 2: x = PLAYER_2; break;
      case 3: x = SQUARE_3; break;
      case 4: x = SQUARE_4; break;
      case 5: x = SQUARE_5; break;
      case 6: x = SQUARE_6; break;
      case 7: x = SQUARE_7; break;
      default: x = UNKNOWN_SQUARE; break;
      }
      world.drawCharacterBox(i, j, x);
    }
  }
}



// __________________________________________________________________________
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//                        Canvas Drawing Events
// __________________________________________________________________________
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


// takes a parsed game state message object (array of key:object pairs).
// iterates through each one, and draws them on the screen.
// TODO: use the KEY (which is the ID) to do something
// TODO: add support for different TYPES of objects
/*var DrawGameStateObjects = function() {
    w.reDraw();
    DrawTreesFromBoolMatrix(w, MatrixOfTrees);
    Object.keys(ListOfObjects).forEach(function (key) {
        try {   
            A = list[key].Location[0];
            B = list[key].Location[1];
        } catch(e) {
            //console.log("Location can't be parsed.");
            return;
        }
        w.drawCharacterBox(A, B, gimmeColor(key));
    });
};
*/

// Tries to return a number between 0 and 255.
// Not really a PRNG, its just a cosine function.
// Used for making colors that stay consistent with player id's.
/*function simplePRNGbyte(n) 
{
    return (Math.cos(n* 255)+1) * 255 >> 1;
}

function gimmeColor(id) 
{
    var r = simplePRNGbyte(id).toString();
    var g = '0';
    var b = simplePRNGbyte(id << 1).toString();
    return 'rgb('+r+','+g+','+b+')';
}

*/





// __________________________________________________________________________
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//                           Decoding Messages
// __________________________________________________________________________
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// myDecode decodes a Base64 string into an array of bytes. (uint8)
//
// Credits: stack overflow; people who asked & answered the question:
// https://stackoverflow.com/questions/16245767/creating-a-blob-from-a-base64-string-in-javascript
//
/*function myDecode(msg) {
    byteCharacters = atob(msg);
    var byteNumbers = new Array(byteCharacters.length);
    for (var i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    var byteArray = new Uint8Array(byteNumbers);
    return byteArray;
}

function Uint8ArrayToMatrix(byteArray, w, h) {
    var matrix = [];
    var mySlice = [];
    for (var i = 0; i < h; i++) {
        matrix.push(byteArray.slice(i*w, (i+1)*w)); 
    }
    return matrix;
}

function UpdateMatrix(msg) {
    return Uint8ArrayToMatrix(myDecode(msg), MAP_WIDTH, MAP_HEIGHT)
}

*/
// ByteArrayToBoolMatrix converts []uint8  --into-->  [][]bool.
//
// Warning!  There is minimal error checking.  It is assumed that you do not
// have any leftover bits!  For now, Only input a byteArray if the last byte
// fully describes 8 booleans.
//  ByteArrayToBoolMatrix

/*


function ByteArrayToBoolMatrix(byteArray, h) {
    p = ByteArrayToBoolArray(byteArray);
    q = BoolArrayToBoolMatrix(p, h);
    return q;
}

function ByteArrayToBoolArray(byteArray) {
    var counter = 0;
    var outputArray = [];
    var L = byteArray.length;

    for (var i = 0; i < L; i++) {
        var val = byteArray[i];
        var slice = [];
        for (var j = 7; j >= 0; j--) {
            if (val >= (1 << j)) {
                slice.unshift(true);
                val -= (1 << j);
            } else {
                slice.unshift(false);
            }
        }
        outputArray.push.apply(outputArray, slice);
    }
    return outputArray;
}

function BoolArrayToBoolMatrix(boolArray, h) {
    var matrix = [];
    counter = 0;
    for (var i = 0; i < h; i++) {
        var slice = [];
        for (var j = 0; j < h; j++) {
            slice.push(boolArray[counter]);
            counter++;
        }
        matrix.push(slice);
    }
    return matrix;
}


*/



// __________________________________________________________________
    //                    Chat Room 
    // ------------------------------------------------------------------

/*
    function appendLog(item) 
    {
        log.appendChild(item);
        // var doScroll = log.scrollTop > log.scrollHeight - log.clientHeight - 1;
        // if (doScroll) {
        log.scrollTop = log.scrollHeight - log.clientHeight;
        // }
    }


    var toggleGameChatroom = function () {
        if (MyMessageWrap.className == "visible") {
            MyMessageWrap.className = "invisible";     
        } else {
            MyMessageWrap.className = "visible";
        }
    };

    ToggleButton.onfocus = function() {
        if (ToggleButton.tabIndex == 0) {
            ToggleButton.tabIndex = 1;
        }
    };
    ToggleButton.onclick = function () {toggleGameChatroom();};
    ToggleButton.onkeypress = function() {toggleGameChatroom();};

    var makePersonalLogEntry = function (stuff) {
        var item = document.createElement("div");
        item.className = 'message personal';
        item.innerText = stuff;
        appendLog(item);
    };

};



*/





// __________________________________________________________________________
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//                           Borrowed Snippets
// __________________________________________________________________________
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



/*
// __________________________________________________________________
//               Credits For The Following Code Snippets 
//
//          "Javascript: The Definitive Guide, 6th Edition"
//                         by David Flanagan
//                Published by O'Reilly Media, Inc., 2011
//
// ------------------------------------------------------------------
// Define a regular polygon with n sides, centered at (x,y) with radius r.
// The vertices are equally spaced along the circumference of a circle.
// Put the first vertex straight up or at the specified angle.
// Rotate clockwise, unless the last argument is true.
function polygon(c,n,x,y,r,angle,counterclockwise) {
    angle = angle || 0;
    counterclockwise = counterclockwise || false;
    c.moveTo(x + r*Math.sin(angle),  // Begin a new subpath at the first vertex
             y - r*Math.cos(angle)); // Use trigonometry to compute position
    var delta = 2*Math.PI/n;         // Angular distance between vertices
    for(var i = 1; i < n; i++) {     // For each of the remaining vertices
        angle += counterclockwise?-delta:delta; // Adjust angle
        c.lineTo(x + r*Math.sin(angle),         // Add line to next vertex
                 y - r*Math.cos(angle));
    }
    c.closePath();                   // Connect last vertex back to the first
}
// ==================================================================
var deg = Math.PI/180;  // For converting degrees to radians
// ==================================================================
// Draw a level-n Koch Snowflake fractal on the canvas context c,
// with lower-left corner at (x,y) and side length len.
function snowflake(c, n, x, y, len) {
    c.save();           // Save current transformation
    c.translate(x,y);   // Translate origin to starting point
    c.moveTo(0,0);      // Begin a new subpath at the new origin
    leg(n);             // Draw the first leg of the snowflake
    c.rotate(-120*deg); // Now rotate 120 degrees counterclockwise
    leg(n);             // Draw the second leg
    c.rotate(-120*deg); // Rotate again
    leg(n);             // Draw the final leg
    c.closePath();      // Close the subpath
    c.restore();        // And restore original transformation

    // Draw a single leg of a level-n Koch snowflake.
    // This function leaves the current point at the end of the leg it has
    // drawn and translates the coordinate system so the current point is (0,0).
    // This means you can easily call rotate() after drawing a leg.
    function leg(n) {
        c.save();               // Save the current transformation
        if (n == 0) {           // Nonrecursive case:
            c.lineTo(len, 0);   //   Just draw a horizontal line
        }                       //                                       _  _
        else {                  // Recursive case: draw 4 sub-legs like:  \/
            c.scale(1/3,1/3);   // Sub-legs are 1/3rd the size of this leg
            leg(n-1);           // Recurse for the first sub-leg
            c.rotate(60*deg);   // Turn 60 degrees clockwise
            leg(n-1);           // Second sub-leg
            c.rotate(-120*deg); // Rotate 120 degrees back
            leg(n-1);           // Third sub-leg
            c.rotate(60*deg);   // Rotate back to our original heading
            leg(n-1);           // Final sub-leg
        }
        c.restore();            // Restore the transformation
        c.translate(len, 0);    // But translate to make end of leg (0,0)
    }
}
// ==================================================================
*/


</script>
        <style type="text/css">
            html {
                overflow: hidden;
            }
            body {
                position: fixed;
                padding: 0;
                margin: 0;
                width: 100%;
                height: 100%;
                background: #522;
            }
            .visible {
                display: all;
            }
            .invisible {
                display: none;
            }
            .greenText {
              color: #6C6;
            }
            .blueText {
              color: #88F;
            }
            .purpleText {
              color: #88F;
            }
            .redText {
              color: #F33;
            }
            .pinkText {
              color: pink;
            }
            .grayText {
              color: #AAA;
            }
            #GameWrap {
              z-index: 5;
            }
            #MessageWrap {
                height: calc(100% - 2em);
                position: fixed;
                width: 100%;
                overflow: hidden;
                top: 0 ;
                background: #000;
            }
            #LogWrap {
                height: calc(100% - 2em);
            }
            #CanvasWrap {
                position: fixed;
                display: block;
                top: 0;
                bottom: calc(2em + 2px);
                left: 0;
                right: 0;
                overflow: hidden;
            }
            #CanvasArea {
                display: block;
                max-width: 100%;
                max-height: 100%;
                background: #555;
                overflow: auto;
            }
            #CanvasBorder {
                border: solid 2px white;
            }

            #MainCanvas {
                display: block;
                margin: 0 auto;
                background: #333;
                resize: all;
            }
            .message {
                margin: 0.1em 0;
                padding: 0.1em 0.5em;
            }
            #log {
                height: 100%;
                color: #0C0;
                overflow: auto;
                font-family: monospace;
                white-space: nowrap;
            }
            #commandForm {
                display: flex;
                flex-direction: row;
                height: 2em;
            }
            #commandTextInput {
                flex: 1;
            }
            #msg {
                width: 80%;
            }
            .personal {
                color: white;
            }
            #ButtonToggleCLI:hover {
                background: #805;
            }
            select:focus, input:focus {
                background: #cef;
            }

            #ButtonToggleCLI:focus {
                background: #158;
            }

            #ButtonToggleCLI:active {
                background: #095;
            }

            #InfoBar {
                position: fixed;

                bottom: 0;
                left: 0;
                right: 0;
                background: #000;
                height: calc(2em + 2px);
                vertical-align: middle;
                text-align: center;
                user-select: none;
            }
            #InfoBarText,
            #ButtonToggleText {
                overflow-x: auto;
                padding: 0 1em;
                user-select: none;
                line-height: calc(2em);
                text-align: center;
                color: white;
                white-space: nowrap;
            }
            #InfoBar_Generation,
            #InfoCountDisputes,
            #InfoCountBlues,
            #InfoCountGreens {
              font-family: monospace;
              display: inline-block;
              width: 4ch;
            }
            #InfoCountGreens {
              color: #9F9;
            }

            #InfoCountBlues {
              color: #77F;
            }
            #InfoCountDisputes {
              color: #FAA;
            }
            #ColorSelect {
                position: fixed;
                width: 20em;
                height: 3em;
            }
            #DisplayTurn {
              top: 0;
              left: calc(50% - 10em);
              right: calc(50% - 10em);
              width: 20em;
              background: rgba(0, 0, 0, 0.7);
              position: fixed;
              line-height: 2em;
              color: white;
              text-align: center;
              pointer-events: none;
              user-select: none;
              z-index: 3;
            }
            #DisplayTurnPlayerNumber {
              font-family: monospace;
              width: 1ch;
            }
            #DisplayRoundsLeft {
              font-family: monospace;
              width: 2ch;
            }
            #DisplayEndGame {
              z-index: 1;
              border: 1px solid gray;
              text-align: center;
              padding: 2px;
              overflow: auto;
              position: fixed;
              top: calc(50% - 7em);
              bottom: calc(50% - 5em);
              right: calc(50% - 10em);
              left: calc(50% - 10em);
              background: rgba(0, 0, 0, 0.6);
              color: white;
              box-shadow: 0px 0px 10px 1px;
            }
            #Instructions {
              z-index: 1;
              border: 2px solid white;
              text-align: center;
              padding: 2px;
              overflow: auto;
              position: fixed;
              top: 0;
              left: 0;
              right: 0;
              bottom: 2em;
              background: rgba(0, 0, 0, 0.9);
              color: white;
            }
            #InstructionsTextWrap {
              max-width: 40em;
              margin: auto;
            }
            #ButtonStartGame {
              font-size: 200%;
            }
            h2 {
              border-bottom: 1px solid white;
              display: inline-block;
              margin-bottom: 0em;
            }
            option {
                height: 2em;
            }
        </style>
</head>
<body id="theBody">

  <div id="DisplayTurn" class="invisible">
    <span id="DisplayTurnPlayerColor" class="greenText"> Player <span id="DisplayTurnPlayerNumber">1</span>'s Turn</span> - Rounds Left: ( <span id="DisplayRoundsLeft">25</span> ) 
  </div>

  <div id="GameWrap">
    <div id="CanvasWrap">
      <div id="CanvasArea">
        <div id="CanvasBorder">
          <canvas id="MainCanvas" width="1248" height="1248"></canvas>
        </div>
      </div>
    </div>

    <div id="DisplayEndGame" class="invisible">
      <p>The Game has ended!</p>
      <p><span id="DisplayEndGameWinner">Nobody has won!</span></p>
      <p><button id="ButtonPlayAgain">Play Again!</button></p>
    </div>
  </div> <!-- End of Game Wrapper -->
  
  <div id="Instructions" class="visible">
    <div id="InstructionsTextWrap">
      <h1>Welcome to the Game!</h1>
        <p><button id="ButtonStartGame">Start Game!</button></p>
      <h2>Colored Squares</h2>
        <p>Player 1 is <span class="greenText">Green</span>.</p>
        <p>Player 2 is <span class="blueText">Blue</span>.</p>
        <p>Disputed Squares are <span class="redText">Red</span>, <span class="pinkText">Pink</span>, or <span class="grayText">Gray</span></p>
      <h2>How to Win</h2>
        <p>The Goal is to have the most squares in your color at the end of 25 rounds.</p>
      <h2>During Each Round</h2>
        <p>Each player selects a square on which to drop ðŸ’¥<span class="redText">La Bomba</span>ðŸ’¥.  This will clear out nearby squares, and advance the game by 1 generation.</p>
      <h2>At the End</h2>
        <p>After all of the rounds are finished, player input will stop, the game will advance a few generations on its own, and then all of the square will be counted.</p>
      <h2>Info Bar</h2>
      <p>The Info Bar is at the bottom of the screen.  It shows the game's current generation, and the number of squares each player has.</p>
     
    </div>
  </div>

  <div id="InfoBar">
    <div id="InfoBarText">
      ~~ Generation:( <span id="InfoBar_Generation">0</span> ) ~~
      Player1:( <span id="InfoCountGreens">0</span> ) ~~ 
      Player2:( <span id="InfoCountBlues">0</span> ) ~~
      Disputed:( <span id="InfoCountDisputes">0</span> ) ~~
    </div>
  </div>



</body>
</html>
